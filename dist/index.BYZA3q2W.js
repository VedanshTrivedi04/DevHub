import{r as reactExports,a as React}from"./index.4jEVUAYB.js";import{j as jsxRuntimeExports}from"./jsx-runtime.qlzv8qiM.js";function setRef(ref,value){if(typeof ref=="function")return ref(value);ref!=null&&(ref.current=value)}function composeRefs(...refs){return node=>{let hasCleanup=!1;const cleanups=refs.map(ref=>{const cleanup=setRef(ref,node);return!hasCleanup&&typeof cleanup=="function"&&(hasCleanup=!0),cleanup});if(hasCleanup)return()=>{for(let i=0;i<cleanups.length;i++){const cleanup=cleanups[i];typeof cleanup=="function"?cleanup():setRef(refs[i],null)}}}}function useComposedRefs(...refs){return reactExports.useCallback(composeRefs(...refs),refs)}var REACT_LAZY_TYPE=Symbol.for("react.lazy"),use=React[" use ".trim().toString()];function isPromiseLike(value){return typeof value=="object"&&value!==null&&"then"in value}function isLazyComponent(element){return element!=null&&typeof element=="object"&&"$$typeof"in element&&element.$$typeof===REACT_LAZY_TYPE&&"_payload"in element&&isPromiseLike(element._payload)}function createSlot(ownerName){const SlotClone=createSlotClone(ownerName),Slot2=reactExports.forwardRef((props,forwardedRef)=>{let{children,...slotProps}=props;isLazyComponent(children)&&typeof use=="function"&&(children=use(children._payload));const childrenArray=reactExports.Children.toArray(children),slottable=childrenArray.find(isSlottable);if(slottable){const newElement=slottable.props.children,newChildren=childrenArray.map(child=>child===slottable?reactExports.Children.count(newElement)>1?reactExports.Children.only(null):reactExports.isValidElement(newElement)?newElement.props.children:null:child);return jsxRuntimeExports.jsx(SlotClone,{...slotProps,ref:forwardedRef,children:reactExports.isValidElement(newElement)?reactExports.cloneElement(newElement,void 0,newChildren):null})}return jsxRuntimeExports.jsx(SlotClone,{...slotProps,ref:forwardedRef,children})});return Slot2.displayName=`${ownerName}.Slot`,Slot2}var Slot=createSlot("Slot");function createSlotClone(ownerName){const SlotClone=reactExports.forwardRef((props,forwardedRef)=>{let{children,...slotProps}=props;if(isLazyComponent(children)&&typeof use=="function"&&(children=use(children._payload)),reactExports.isValidElement(children)){const childrenRef=getElementRef(children),props2=mergeProps(slotProps,children.props);return children.type!==reactExports.Fragment&&(props2.ref=forwardedRef?composeRefs(forwardedRef,childrenRef):childrenRef),reactExports.cloneElement(children,props2)}return reactExports.Children.count(children)>1?reactExports.Children.only(null):null});return SlotClone.displayName=`${ownerName}.SlotClone`,SlotClone}var SLOTTABLE_IDENTIFIER=Symbol("radix.slottable");function isSlottable(child){return reactExports.isValidElement(child)&&typeof child.type=="function"&&"__radixId"in child.type&&child.type.__radixId===SLOTTABLE_IDENTIFIER}function mergeProps(slotProps,childProps){const overrideProps={...childProps};for(const propName in childProps){const slotPropValue=slotProps[propName],childPropValue=childProps[propName];/^on[A-Z]/.test(propName)?slotPropValue&&childPropValue?overrideProps[propName]=(...args)=>{const result=childPropValue(...args);return slotPropValue(...args),result}:slotPropValue&&(overrideProps[propName]=slotPropValue):propName==="style"?overrideProps[propName]={...slotPropValue,...childPropValue}:propName==="className"&&(overrideProps[propName]=[slotPropValue,childPropValue].filter(Boolean).join(" "))}return{...slotProps,...overrideProps}}function getElementRef(element){let getter=Object.getOwnPropertyDescriptor(element.props,"ref")?.get,mayWarn=getter&&"isReactWarning"in getter&&getter.isReactWarning;return mayWarn?element.ref:(getter=Object.getOwnPropertyDescriptor(element,"ref")?.get,mayWarn=getter&&"isReactWarning"in getter&&getter.isReactWarning,mayWarn?element.props.ref:element.props.ref||element.ref)}export{Slot as S,createSlot as a,composeRefs as c,useComposedRefs as u};
